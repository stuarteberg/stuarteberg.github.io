{"name":"Eternal Journeyman","tagline":"","body":"# Tutorial: LD_LIBRARY_PATH, soname, and rpath\r\n\r\n(This little tutorial is written for Linux, but the Mac OS X version is basically the same.  Use `otool -L` instead of `ldd`, and replace `-soname` with `-install_name`. Also, the keyword for `$ORIGIN` is not the same.)\r\n\r\nBefore we start talking about shared objects, let's make one:\r\n\r\n    $ mkdir /tmp/example\r\n    $ cd /tmp/example\r\n    $ cat > foo.c\r\n    #include <stdio.h>\r\n    void greet() { printf(\"Hello from foo.c\\n\"); }\r\n    $ cat > foo.h\r\n    void greet();\r\n    $ gcc -shared -fPIC -o foo.so foo.c\r\n    $ ls\r\n    foo.c   foo.h   foo.so\r\n\r\nGreat.  Now let's try to use it:\r\n\r\n    $ cat > main.c\r\n    int main() { greet(); } \r\n    $ gcc -o main main.c foo.so\r\n    $ ls\r\n    foo.c   foo.h   foo.so main   main.c\r\n\r\nLooks good so far... Does it work?\r\n\r\n    $ ./main\r\n    Hello from foo.c\r\n\r\nSure does.  We can use `ldd` to see that our executable does, in fact, depend on `foo.so`:\r\n\r\n    $ ldd main\r\n        linux-vdso.so.1 =>  (0x00007fff06193000)\r\n        foo.so (0x00007fee81382000)\r\n        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fee80fbc000)\r\n        /lib64/ld-linux-x86-64.so.2 (0x00007fee81586000)\r\n\r\nIs our executable ready for general use?  For example, what happens if we switch directories and try to run it again?\r\n\r\n    $ cd /\r\n    $ /tmp/example/main \r\n    /tmp/example/main: error while loading shared libraries: foo.so: cannot open shared object file: No such file or directory\r\n\r\nOuch.  What went wrong?  Before we switch directories again, let's see what `ldd` can tell us:\r\n\r\n    $ ldd /tmp/example/main\r\n        linux-vdso.so.1 =>  (0x00007fffc17ff000)\r\n        foo.so => not found\r\n        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007faaaaba0000)\r\n        /lib64/ld-linux-x86-64.so.2 (0x00007faaaaf67000)\r\n\r\nHmm... the loader knows that our executable depends on something called `foo.so`, but it doesn't know where to find it.  How can we help it?\r\n\r\n## Option 1: LD_LIBRARY_PATH\r\n\r\nThere's a special environment variable called `LD_LIBRARY_PATH` that can be used to tell the loader where to look for `.so` files.  Let's give it a try:\r\n\r\n    $ export LD_LIBRARY_PATH=/tmp/example\r\n    $ /tmp/example/main\r\n    Hello from foo.c\r\n\r\nOkay, that worked, but it may not be convenient to require our users to have a special environment setup.\r\n\r\n## Option 2: Hard-code the path in the foo.so soname.\r\n\r\nLet's back up a bit.  When we built `foo.so`, we didn't give any though to the loader.  Let's rebuild it with a custom `soname` setting:\r\n\r\n    $ gcc -shared -fPIC -o foo.so -Wl,-soname,/tmp/example/foo.so foo.c\r\n\r\nAfter rebuilding our main executable, what does ldd say?\r\n\r\n    $ gcc -o main main.c foo.so\r\n    $ ldd main\r\n        linux-vdso.so.1 =>  (0x00007fff8d987000)\r\n        /tmp/example/foo.so (0x00007f6b85c97000)\r\n        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f6b858d2000)\r\n        /lib64/ld-linux-x86-64.so.2 (0x00007f6b85e9b000)\r\n\r\nNow the path to `foo.so` is hard-coded into our executable.  We should't need LD_LIBRARY_PATH any more, right?\r\n\r\n    $ cd /\r\n    $ export LD_LIBRARY_PATH=\r\n    $ /tmp/example/main\r\n    Hello from foo.c\r\n\r\nLooks good!  But wait, this means that we can't ever move `foo.so` out of `/tmp/example`.  In fact, if foo.so is moved, our `main` executable won't run, no matter what changes we make to `LD_LIBRARY_PATH`.  If you can count on your shared object being installed to a standard location, then maybe that's okay.  If not, do you have any other options?\r\n\r\n## Option 3: Hard-code the library search directory in main's rpath\r\n\r\nThis time, we'll leave `foo.so`'s `soname` alone.  Instead, we'll tell `main` where to look for its dependencies:\r\n\r\n    $ gcc -o main main.c foo.so\r\n    $ gcc -o main -Wl,-rpath,/tmp/example main.c foo.so\r\n\r\nWe can verify that our executable has our custom `rpath` using the `chrpath` tool:\r\n\r\n    $ chrpath main\r\n    main: RPATH=/tmp/example\r\n\r\nSo, can we execute our program even if we switch to some other directory?\r\n\r\n    $ cd /\r\n    $ /tmp/example/main\r\n    Hello from foo.c\r\n\r\nNice.  But... This solution seems just as fragile as the `soname` change above (Option 2).  Are there any advantages to using `rpath` to locate our shared object?  Yes!  If we plan to distribute our main executable alongside our shared object as part of a larger package, we can use a relative path.  The special variable `$ORIGIN` is recognized inside the `rpath` to enable this feature:\r\n\r\n    $ gcc -o main -Wl,-rpath,\\$ORIGIN/. main.c foo.so\r\n    $ chrpath main\r\n    main: RPATH=$ORIGIN/.\r\n\r\nNote that there are quoting issues to worry about here.  I used a `\\` to prevent the shell from misinterpreting `$ORIGIN` as an environment variable.\r\n\r\nMore than one search path can be listed in an `rpath`.  One way to include multiple paths is to simply pass the `-rpath` setting to the linker more than once:\r\n\r\n    $ gcc -o main -Wl,-rpath,\\$ORIGIN/. -Wl,-rpath,\\$ORIGIN/../../lib main.c foo.so\r\n    $ chrpath main\r\n    main: RPATH=$ORIGIN/.:$ORIGIN/../../lib\r\n\r\nThis way, if you have a whole directory tree with shared objects and executable programs in subdirectories, you can use relative `rpath`s to help locate the shared objects.  Furthermore, if you copy the whole directory tree and give it to somebody else, it should work on their system, too, no matter where they store it on their hard drive.\r\n\r\nOne last note: the `chrpath` utility can also be used to *change* the `rpath` in an executable or shared object.  That's handy if you've already built the binary and you just want to update the rpath before shipping it.  (See the man page for details.)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}